#! /usr/bin/env python
''' Socket streaming for picamera

'''

# TODO: integrate into deepi-python

import io
import socket
import struct
import time
import logging
import picamerax as picamera

from threading import Thread

class SplitFrames:
    def __init__(self, connection):
        self.connection = connection
        self.stream = io.BytesIO()
        self.count = 0

    def write(self, buf):
        if buf.startswith(b'\xff\xd8'): # Start of new frame
            # send the old one's length then the data
            size = self.stream.tell()
            if size > 0:
                self.stream.seek(0)
                try:
                    self.connection.write(struct.pack('<L', size))
                    self.connection.flush()
                    self.connection.write(self.stream.read(size))
                except Exception as e:
                    logging.debug("Connection lost.")
                    raise(e)
                self.count += 1
                self.stream.seek(0)
        self.stream.write(buf)


class StreamerTx:

    def __init__(self, port=8000):

        self.sock = socket.socket()
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind(('0.0.0.0',port))
        self.sock.listen(0)

        logging.debug(f"Ready to connect streamer on port {port}")
        self.conn = self.sock.accept()[0].makefile('wb')
        logging.debug("Streamer connected")

        self.output = SplitFrames(self.conn)
        logging.debug("Output started")

    def __enter__(self):
        logging.debug(f"Entering streaming context on port")
        return self.output

    def __exit__(self,exc_type,exc_value,exc_tb):
        logging.debug("Exiting streaming context")
        self.stop()
        self.close()

    def stop(self):
        try:
            self.conn.write(struct.pack('<L', 0))
        except Exception as e:
            logging.debug(f"Error on stop_recording {e}")

    def close(self):
        try:
            self.conn.close()
        except BrokenPipeError as e:
            logging.debug("Connection already closed")
        self.sock.close()


class ControllerRx(Thread):

    def __init__(self,picam:picamera.PiCamera, port=9000):

        self.picam = picam
        self.sock = socket.socket()
        self.sock.bind(('0.0.0.0',port))
        self.sock.listen(0)

        logging.debug("Ready to connect controller")
        self.conn, addr = self.sock.accept()
        logging.debug("Controller connected")
        Thread.__init__(self)
        self.start()

    def run(self):

        while True:
            data = self.conn.recv(1024)
            if not data:
                break
            logging.debug(f"Recieved: {data}")

        self.close()
    

    def close(self):
        logging.debug("Closing socket")
        self.sock.close()
        logging.debug("Socket closed")


if __name__=='__main__':
    
    ''' Generate a stream available to a single client and keep the stream open

    '''

    logging.basicConfig(format='%(levelname)s: %(message)s',level=logging.DEBUG)

    #ctrl = ControllerRx(picam)

    resolution = '1080p'
    framerate = 24

    # resolution = (1920,1080)
    # framerate = 60


    while True:
        with  StreamerTx(8000) as output:
            with picamera.PiCamera(resolution=resolution, framerate=framerate) as picam:
                time.sleep(2)

                picam.start_recording(output, format='mjpeg')
                start = time.time()

                try:
                    while True:
                        picam.wait_recording(5)
                except Exception as e:
                    pass

                finish = time.time()
                try:
                    picam.stop_recording()
                except BrokenPipeError:
                    pass

            logging.info(f'Sent {output.count} frames in {finish-start:.1f} seconds '\
                         f'({output.count/(finish-start):.1f}fps)')
            time.sleep(1)
                
        #ctrl.close()
        


